name: Update products.json from Baserow (with HTML fallback)

on:
  schedule:
    - cron: "0 * * * *"   # stündlich
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch Baserow public view (try JSON, CSV, then HTML)
        run: |
          set -e
          SLUG="uSOIDTc6fT_AkuuyIc-wYUQCgD1XCz0SMM3k8MVQ-OA"
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119 Safari/537.36"

          CANDIDATES=(
            "https://db.pflugsmuehle.de/public/grid/${SLUG}/export/?format=json"
            "https://db.pflugsmuehle.de/public/grid/${SLUG}/export/?format=csv"
            "https://db.pflugsmuehle.de/public/grid/${SLUG}"
          )

          rm -f raw_baserow.*
          SUCCESS_URL=""
          for URL in "${CANDIDATES[@]}"; do
            echo ">> Versuch: $URL"
            HTTP_CODE=$(curl -sS -L -A "$UA" -w "%{http_code}" -o raw.tmp "$URL" || true)
            echo "HTTP_CODE=$HTTP_CODE"
            head -c 200 raw.tmp | sed 's/[^[:print:]\t]//g' || true; echo
            if [ "$HTTP_CODE" = "200" ]; then SUCCESS_URL="$URL"; break; fi
          done

          if [ -n "$SUCCESS_URL" ]; then
            if echo "$SUCCESS_URL" | grep -qi 'format=json'; then
              mv raw.tmp raw_baserow.json
            elif echo "$SUCCESS_URL" | grep -qi 'format=csv'; then
              mv raw.tmp raw_baserow.csv
            else
              mv raw.tmp raw_baserow.html
            fi
            echo "Erfolgreich geladen von: $SUCCESS_URL"
          else
            echo "Keine URL mit HTTP 200 erreichbar."
            mv raw.tmp raw_baserow.fail || true
          fi

      - name: Map to products.json (JSON, CSV oder HTML)
        run: |
          set -e
          node - <<'EOF'
          const fs = require('fs');

          const toNum = v => {
            if (v === null || v === undefined) return 0;
            const s = String(v).trim();
            // Tausenderpunkte entfernen, Komma zu Punkt
            const n = Number(s.replace(/\./g,'').replace(',', '.'));
            return isNaN(n) ? 0 : n;
          };

          function parseCSV(text) {
            const headerLine = (text.split(/\r?\n/)[0] || '');
            let delim = ';';
            const commas = (headerLine.match(/,/g) || []).length;
            const semis  = (headerLine.match(/;/g) || []).length;
            if (commas > semis) delim = ',';

            const rows = [];
            let i = 0, field = '', inQuotes = false, row = [];
            while (i < text.length) {
              const c = text[i];
              if (inQuotes) {
                if (c === '"') {
                  if (text[i+1] === '"') { field += '"'; i++; }
                  else inQuotes = false;
                } else field += c;
              } else {
                if (c === '"') inQuotes = true;
                else if (c === '\r') {}
                else if (c === '\n') { row.push(field); rows.push(row); row = []; field = ''; }
                else if (c === delim) { row.push(field); field = ''; }
                else field += c;
              }
              i++;
            }
            if (field.length > 0 || row.length > 0) { row.push(field); rows.push(row); }
            return rows;
          }

          function stripHtml(s) {
            return String(s||'').replace(/<[^>]*>/g,'').replace(/\s+/g,' ').trim();
          }

          function parseHTMLTable(html) {
            // erste Tabelle greifen
            const tableMatch = html.match(/<table[\s\S]*?<\/table>/i);
            if (!tableMatch) return [];
            const table = tableMatch[0];

            // Header
            const ths = [...table.matchAll(/<th[^>]*>([\s\S]*?)<\/th>/gi)].map(m => stripHtml(m[1]));
            if (!ths.length) {
              // Alternative: erste Zeile <tr> als Header
              const firstTr = table.match(/<tr[\s\S]*?<\/tr>/i);
              if (firstTr) {
                const altThs = [...firstTr[0].matchAll(/<t[hd][^>]*>([\s\S]*?)<\/t[hd]>/gi)].map(m => stripHtml(m[1]));
                if (altThs.length) ths.push(...altThs);
              }
            }

            // Zeilen
            const trs = [...table.matchAll(/<tr[^>]*>([\s\S]*?)<\/tr>/gi)].map(m => m[1]);
            // erste ist header -> skip
            const dataTrs = trs.slice(1);

            const rows = [];
            for (const tr of dataTrs) {
              const tds = [...tr.matchAll(/<t[dh][^>]*>([\s\S]*?)<\/t[dh]>/gi)].map(m => stripHtml(m[1]));
              if (tds.length) rows.push(tds);
            }
            return { header: ths, rows };
          }

          let out = [];

          if (fs.existsSync('raw_baserow.json')) {
            const txt = fs.readFileSync('raw_baserow.json','utf8').trim();
            const data = JSON.parse(txt);
            const rows = Array.isArray(data) ? data : (data.results || []);
            out = rows.map(r => ({
              id: r['Artikel-ID'] ?? r.id,
              name: r['Beschreibung'] ?? r['Name'] ?? '',
              price_gross: toNum(r['Bruttopreis']),
              vat_rate: toNum(r['MwSt-Satz']),
            })).filter(x => x.name);
            console.log('Quelle: JSON, Artikel:', out.length);
          } else if (fs.existsSync('raw_baserow.csv')) {
            const csv = fs.readFileSync('raw_baserow.csv','utf8').trim();
            const table = parseCSV(csv);
            const header = table[0].map(h => h.trim());
            const find = (re) => header.findIndex(h => re.test(h));
            const iId   = find(/artikel[- ]?id/i);
            const iName = find(/beschreibung|name/i);
            const iBrut = find(/bruttopreis/i);
            const iMwst = find(/mwst|mwst-satz|mehrwertsteuer/i);
            for (let r = 1; r < table.length; r++) {
              const row = table[r];
              const name = (row[iName] || '').trim();
              if (!name) continue;
              out.push({
                id: (row[iId] || '').trim() || String(r),
                name,
                price_gross: toNum(row[iBrut]),
                vat_rate: toNum(row[iMwst]),
              });
            }
            console.log('Quelle: CSV, Artikel:', out.length);
          } else if (fs.existsSync('raw_baserow.html')) {
            const html = fs.readFileSync('raw_baserow.html','utf8');
            const parsed = parseHTMLTable(html);
            if (!parsed || !parsed.rows || !parsed.rows.length) {
              console.error('HTML enthielt keine Tabelle mit Daten.');
            } else {
              const H = parsed.header.map(h => h.toLowerCase());
              const find = (re) => H.findIndex(h => re.test(h));
              const iId   = find(/artikel[- ]?id|id/i);
              const iName = find(/beschreibung|name/i);
              const iBrut = find(/bruttopreis|preis/i);
              const iMwst = find(/mwst|mwst-satz|mehrwertsteuer/i);

              for (const row of parsed.rows) {
                const name = (row[iName] || '').trim();
                if (!name) continue;
                out.push({
                  id: (row[iId] || '').trim(),
                  name,
                  price_gross: toNum(row[iBrut]),
                  vat_rate: toNum(row[iMwst]),
                });
              }
              console.log('Quelle: HTML, Artikel:', out.length);
            }
          } else {
            console.log('Keine Rohdaten-Datei vorhanden – übersprungen.');
          }

          if (out.length) {
            fs.writeFileSync('products.json', JSON.stringify(out, null, 2));
            console.log('products.json geschrieben.');
          } else {
            console.log('0 Artikel – products.json nicht verändert.');
          }
          EOF

      - name: Upload raw artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: baserow-raw
          path: |
            raw_baserow.*
            products.json
          if-no-files-found: warn

      - name: Commit changes (if any)
        run: |
          if [ -f products.json ]; then
            if git diff --quiet -- products.json; then
              echo "No changes in products.json"
            else
              git config user.name "github-actions[bot]"
              git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
              git add products.json
              git commit -m "Update products.json (HTML fallback)"
              git push
            fi
          else
            echo "products.json wurde nicht erzeugt – kein Commit."
          fi
