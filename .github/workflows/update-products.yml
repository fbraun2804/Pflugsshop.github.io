name: Update products.json from Baserow (robust)

on:
  schedule:
    - cron: "0 * * * *"   # stündlich
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Fetch Baserow (try JSON export, then CSV)
        run: |
          set -e
          SLUG="uSOIDTc6fT_AkuuyIc-wYUQCgD1XCz0SMM3k8MVQ-OA"
          UA="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119 Safari/537.36"

          # Kandidaten in Reihenfolge: direkter JSON-Export, CSV-Export, HTML (nur zum Debuggen)
          CANDIDATES=(
            "https://db.pflugsmuehle.de/public/grid/${SLUG}/export/?format=json"
            "https://db.pflugsmuehle.de/public/grid/${SLUG}/export/?format=csv"
            "https://db.pflugsmuehle.de/public/grid/${SLUG}"
          )

          rm -f raw_baserow.*
          SUCCESS_URL=""
          for URL in "${CANDIDATES[@]}"; do
            echo ">> Versuch: $URL"
            # -L follow redirects, -s silent, -S show errors, KEIN --fail, damit wir HTTP-Code loggen können
            HTTP_CODE=$(curl -sS -L -A "$UA" -w "%{http_code}" -o raw.tmp "$URL" || true)
            echo "HTTP_CODE=$HTTP_CODE"
            file raw.tmp || true
            head -c 200 raw.tmp | sed 's/[^[:print:]\t]//g' || true; echo

            if [ "$HTTP_CODE" = "200" ]; then
              SUCCESS_URL="$URL"
              break
            fi
            echo "----"
          done

          if [ -z "$SUCCESS_URL" ]; then
            echo "Keine URL mit HTTP 200 erreichbar. Bitte prüfe die Public-View-URL manuell."
            # Trotzdem legen wir eine leere Datei an, damit der nächste Schritt nicht crasht:
            echo "[]" > raw_baserow.json
          else
            # Je nach Format in passende Datei umbenennen
            if echo "$SUCCESS_URL" | grep -qi 'format=json'; then
              mv raw.tmp raw_baserow.json
            elif echo "$SUCCESS_URL" | grep -qi 'format=csv'; then
              mv raw.tmp raw_baserow.csv
            else
              mv raw.tmp raw_baserow.html
            fi
            echo "Erfolgreich geladen von: $SUCCESS_URL"
          fi

      - name: Map to products.json (handles JSON or CSV)
        run: |
          set -e
          node - <<'EOF'
          const fs = require('fs');

          const toNum = (v) => {
            if (v === null || v === undefined) return 0;
            const n = Number(String(v).replace(/\./g, '').replace(',', '.'));
            return isNaN(n) ? 0 : n;
          };

          function parseCSV(text) {
            // sehr einfacher CSV-Parser mit Trenner-Erkennung (, oder ;)
            const headerLine = (text.split(/\r?\n/)[0] || '');
            let delim = ';';
            const commas = (headerLine.match(/,/g) || []).length;
            const semis  = (headerLine.match(/;/g) || []).length;
            if (commas > semis) delim = ',';

            const rows = [];
            let i = 0, field = '', inQuotes = false, row = [];
            while (i < text.length) {
              const c = text[i];
              if (inQuotes) {
                if (c === '"') {
                  if (text[i+1] === '"') { field += '"'; i++; }
                  else inQuotes = false;
                } else field += c;
              } else {
                if (c === '"') inQuotes = true;
                else if (c === '\r') { /* ignore */ }
                else if (c === '\n') { row.push(field); rows.push(row); row = []; field = ''; }
                else if (c === delim) { row.push(field); field = ''; }
                else field += c;
              }
              i++;
            }
            if (field.length > 0 || row.length > 0) { row.push(field); rows.push(row); }
            return rows;
          }

          let out = [];

          if (fs.existsSync('raw_baserow.json')) {
            const txt = fs.readFileSync('raw_baserow.json', 'utf8').trim();
            if (txt.startsWith('{') || txt.startsWith('[')) {
              let data;
              try { data = JSON.parse(txt); }
              catch(e){ console.error('JSON konnte nicht geparst werden.'); process.exit(1); }
              const rows = Array.isArray(data) ? data : (data.results || []);
              out = rows.map(r => ({
                id: r['Artikel-ID'] ?? r.id,
                name: r['Beschreibung'] ?? r['Name'] ?? '',
                price_gross: toNum(r['Bruttopreis']),
                vat_rate: toNum(r['MwSt-Satz']),
              })).filter(x => x.name);
              console.log('Quelle: JSON, Artikel:', out.length);
            }
          } else if (fs.existsSync('raw_baserow.csv')) {
            const csv = fs.readFileSync('raw_baserow.csv','utf8').trim();
            const table = parseCSV(csv);
